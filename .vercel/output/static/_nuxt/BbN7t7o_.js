import{_ as B,o as E,c as O,a as f,d as g,C as M,D as d,h,E as V,G as H,H as N,I as S,J as R,K as b,L as z,u as K,M as T,N as j}from"./DpY7Jxqy.js";const G={},I={class:"call-to-action bg-purple-progress pt-64 pb-10"},$={class:"container mx-auto"},F={class:"w-full text-center"},J=f("h1",{class:"text-5xl text-white font-semibold"},[g(" Easy way to funding "),f("br"),g(" best idea and innovation ")],-1);function L(s,r){return E(),O("section",I,[f("div",$,[f("div",F,[J,f("button",{onClick:r[0]||(r[0]=a=>s.$router.push({path:"/register"})),class:"inline-block bg-orange-button hover:bg-green-button text-white font-semibold px-6 py-4 mt-8 text-lg rounded-full"}," Getting Start ")])])])}const X=B(G,[["render",L]]),U=s=>s==="defer"||s===!1;function Y(...s){var v;const r=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(r);let[a,u,e={}]=s;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof u!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=M(),P=u,w=()=>d.value,C=()=>t.isHydrating?t.payload.data[a]:t.static.data[a];e.server=e.server??!0,e.default=e.default??w,e.getCachedData=e.getCachedData??C,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0,e.deep=e.deep??d.deep,e.dedupe=e.dedupe??"cancel";const _=e.getCachedData(a,t),m=_!=null;if(!t._asyncData[a]||!e.immediate){(v=t.payload._errors)[a]??(v[a]=d.errorValue);const i=e.deep?h:V;t._asyncData[a]={data:i(m?_:e.default()),pending:h(!m),error:H(t.payload._errors,a),status:h("idle"),_default:e.default}}const n={...t._asyncData[a]};delete n._default,n.refresh=n.execute=(i={})=>{if(t._asyncDataPromises[a]){if(U(i.dedupe??e.dedupe))return t._asyncDataPromises[a];t._asyncDataPromises[a].cancelled=!0}if(i._initial||t.isHydrating&&i._initial!==!1){const c=i._initial?_:e.getCachedData(a,t);if(c!=null)return Promise.resolve(c)}n.pending.value=!0,n.status.value="pending";const l=new Promise((c,o)=>{try{c(P(t))}catch(y){o(y)}}).then(async c=>{if(l.cancelled)return t._asyncDataPromises[a];let o=c;e.transform&&(o=await e.transform(c)),e.pick&&(o=Q(o,e.pick)),t.payload.data[a]=o,n.data.value=o,n.error.value=d.errorValue,n.status.value="success"}).catch(c=>{if(l.cancelled)return t._asyncDataPromises[a];n.error.value=z(c),n.data.value=K(e.default()),n.status.value="error"}).finally(()=>{l.cancelled||(n.pending.value=!1,delete t._asyncDataPromises[a])});return t._asyncDataPromises[a]=l,t._asyncDataPromises[a]},n.clear=()=>q(t,a);const D=()=>n.refresh({_initial:!0}),x=e.server!==!1&&t.payload.serverRendered;{const i=T();if(i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const o=i._nuxtOnBeforeMountCbs;N(()=>{o.forEach(y=>{y()}),o.splice(0,o.length)}),S(()=>o.splice(0,o.length))}x&&t.isHydrating&&(n.error.value||_!=null)?(n.pending.value=!1,n.status.value=n.error.value?"error":"success"):i&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?i._nuxtOnBeforeMountCbs.push(D):e.immediate&&D();const l=j();if(e.watch){const o=R(e.watch,()=>n.refresh());l&&b(o)}const c=t.hook("app:data:refresh",async o=>{(!o||o.includes(a))&&await n.refresh()});l&&b(c)}const p=Promise.resolve(t._asyncDataPromises[a]).then(()=>n);return Object.assign(p,n),p}function q(s,r){r in s.payload.data&&(s.payload.data[r]=void 0),r in s.payload._errors&&(s.payload._errors[r]=d.errorValue),s._asyncData[r]&&(s._asyncData[r].data.value=void 0,s._asyncData[r].error.value=d.errorValue,s._asyncData[r].pending.value=!1,s._asyncData[r].status.value="idle"),r in s._asyncDataPromises&&(s._asyncDataPromises[r]&&(s._asyncDataPromises[r].cancelled=!0),s._asyncDataPromises[r]=void 0)}function Q(s,r){const a={};for(const u of r)a[u]=s[u];return a}export{X as _,Y as u};
